# Z80 アセンブリ実践リファレンス（本プロジェクト実装対応）

この文書は `packages/assembler-z80` の実装に合わせた、
**人間が読みながら書けること**を目的にした Z80 命令リファレンスです。

- 対象: 本リポジトリのアセンブラが受け付ける全ニーモニック
- 目的: 命令の意味、オペランド、バイトコード、フラグ、M/T を読み切れること
- 参照基準: Zilog Z80 User Manual（documented 命令）

---

## 0. CPU 基礎

### 0.1 レジスタ詳細

#### 8bit レジスタ

| レジスタ | 役割 | 実務での使いどころ |
|---|---|---|
| `A` | アキュムレータ | 算術・論理・比較の中心。`ADD/ADC/SUB/SBC/AND/OR/XOR/CP` は `A` を軸に動く。 |
| `F` | フラグレジスタ | `S Z Y H X P/V N C` を保持。条件分岐や多バイト演算の判定材料。 |
| `B` | 汎用上位レジスタ | ループカウンタ（`DJNZ`）やブロック I/O 命令でよく使う。 |
| `C` | 汎用下位レジスタ | `IN r,(C)` / `OUT (C),r` で I/O ポート番号の下位 8bit。 |
| `D` / `E` | 汎用 | `DE` として転送先ポインタに使うことが多い。 |
| `H` / `L` | 汎用 | `HL` として最も基本的なメモリ間接アドレス。`(HL)` は頻出。 |
| `I` | 割り込みベクタ上位 | `IM 2` で割り込みベクタテーブル上位を保持。 |
| `R` | リフレッシュカウンタ | `LD A,R` で読める。厳密な汎用カウンタとしては使わない。 |

#### 16bit レジスタ/レジスタペア

| レジスタ | 役割 |
|---|---|
| `AF` | `A` + `F` のペア（`PUSH/POP` 可能） |
| `BC`, `DE`, `HL` | 汎用 16bit 演算とポインタ用途 |
| `SP` | スタックポインタ（スタックは下位アドレス方向へ伸びる） |
| `PC` | プログラムカウンタ（次命令アドレス） |
| `IX`, `IY` | インデックスレジスタ。`(IX+d)`, `(IY+d)` で構造化メモリアクセスに便利 |

#### シャドウレジスタ

- `AF'`, `BC'`, `DE'`, `HL'` の副レジスタ群を持つ。
- `EX AF,AF'` は `AF` 系だけを交換。
- `EXX` は `BC/DE/HL` と `BC'/DE'/HL'` を一括交換。

#### インデックス派生 8bit（本実装対応）

- `IXH`, `IXL`, `IYH`, `IYL` を 8bit レジスタとして使える。
- 実体は `DD` / `FD` プレフィクス付き命令。

### 0.2 フラグ詳細

`F` のビット（bit7..bit0）: `S Z Y H X P/V N C`

| フラグ | 名称 | 典型的な意味 |
|---|---|---|
| `S` | Sign | 結果 bit7（1 なら負数扱い） |
| `Z` | Zero | 結果が 0 なら 1 |
| `Y` | undocumented bit5 | 多くの命令で結果 bit5 を反映 |
| `H` | Half carry/borrow | bit3↔bit4 の桁上がり/桁借り |
| `X` | undocumented bit3 | 多くの命令で結果 bit3 を反映 |
| `P/V` | Parity / Overflow | 論理命令では parity、算術命令では overflow |
| `N` | Add/Subtract | 減算系で 1、加算系で 0 |
| `C` | Carry/Borrow | 最上位桁で桁上がり/桁借り |

#### 本書のフラグ記法（重要）

| 記法 | 意味 |
|---|---|
| `-` | 変化しない |
| `0` | 必ず 0 になる |
| `1` | 必ず 1 になる |
| `*` | 命令結果や条件で変化する |

例:

- `S* Z* H* P/V* N=0 C*` は、`N` だけ固定 0、他は計算結果依存。
- `C=-` はキャリーが保持される（変わらない）。

### 0.3 オペランド・バイトコード表記（読み方）

この章は、後続の全表を読むための「辞書」です。
ここが理解できると、`00ddd110` や `ED 4B/5B/6B/7B i16L i16H` を自分で展開できます。

#### 0.3.1 なぜこの記法を使うのか

Z80 は「命令の一部ビットがレジスタや条件を表す」設計です。
そのため、1 命令ごとに全パターンをベタ書きする代わりに、
**共通形 + 展開表**で仕様を示すと全体像が掴みやすくなります。

ただし本書では、曖昧さを避けるために以下を必ず併記します。

- ビットパターン表記（例: `00ddd110`）
- 実際の Hex 範囲（例: `06/0E/16/1E/26/2E/3E`）
- 変数（`ddd` など）の対応表

#### 0.3.2 変数記号の意味（ソース記法とバイトコード記法を分離）

この文書では、**形式列（アセンブリ）**と**バイトコード列（機械語）**で記号を分けます。

形式列（ソース記法）:

| 記号 | 意味 |
|---|---|
| `n` | 8bit 即値 |
| `nn` | 16bit 即値 |
| `d` | signed 8bit displacement（`-128..+127`） |
| `e` | signed 8bit relative offset（`JR`/`DJNZ`） |
| `r` / `r'` | 8bit レジスタコード（`r` は第1オペランド、`r'` は第2オペランド） |
| `rr` | 16bit レジスタペアコード（`BC/DE/HL/SP`） |
| `qq` | 16bit ペアコード（`BC/DE/HL/AF`） |
| `cond` | 条件コード（`NZ/Z/NC/C/PO/PE/P/M`） |
| `b` | ビット番号（`0..7`） |

バイトコード列（機械語プレースホルダ）:

| 記号 | 意味 |
|---|---|
| `imm8` | 8bit 即値バイト |
| `i16L i16H` | 16bit 即値の下位/上位バイト（リトルエンディアン） |
| `disp8` | `(IX+d)/(IY+d)` の変位バイト（2の補数8bit） |
| `rel8` | `JR` / `DJNZ` の相対オフセットバイト |

補足:

- `i16L i16H` は `1234H -> 34 12` の順で並ぶ。
- `dd` は Z80 文献で 16bit レジスタペア（`BC/DE/HL/SP`）を指すことが多いため、
  本書では変位バイトに `dd` を使わず `disp8` を採用する。

#### 0.3.3 レジスタコード対応表（`r`, `r'`, `rr`, `qq`）

| コード | `r`/`r'` |
|---:|---|
| `000` | `B` |
| `001` | `C` |
| `010` | `D` |
| `011` | `E` |
| `100` | `H` |
| `101` | `L` |
| `110` | `(HL)` |
| `111` | `A` |

| コード | `rr` (`BC/DE/HL/SP`) | `qq` (`BC/DE/HL/AF`) |
|---:|---|---|
| `00` | `BC` | `BC` |
| `01` | `DE` | `DE` |
| `10` | `HL` | `HL` |
| `11` | `SP` | `AF` |

#### 0.3.4 `00ddd110` をどう読むか（具体例）

`LD r,n` をバイトコード欄で書くと `00ddd110 imm8` です。

- `ddd` が転送先レジスタを表す
- `imm8` が 8bit 即値バイト（機械語）

展開すると以下になります（Hex 範囲が分かるよう明示）。

| 命令 | バイトコード |
|---|---|
| `LD B,n` | `06 imm8` |
| `LD C,n` | `0E imm8` |
| `LD D,n` | `16 imm8` |
| `LD E,n` | `1E imm8` |
| `LD H,n` | `26 imm8` |
| `LD L,n` | `2E imm8` |
| `LD A,n` | `3E imm8` |

#### 0.3.5 `DD` / `FD` プレフィクスの読み方

`DD` は `IX` 系、`FD` は `IY` 系を意味します。

| プレフィクス | 意味 |
|---|---|
| `DD` | 後続命令の `HL`/`H`/`L`/`(HL)` を `IX` 系へ置換 |
| `FD` | 後続命令の `HL`/`H`/`L`/`(HL)` を `IY` 系へ置換 |

例:

- `DD 7E 05` = `LD A,(IX+5)`
- `FD 7E 05` = `LD A,(IY+5)`

#### 0.3.6 `M` と `T` の意味

- `M`: machine cycle 数
- `T`: T-state 数

例: `3/2 M, 12/7 T` は「条件成立時が前者、不成立時が後者」を表します。

### 0.4 IFF1 / IFF2（割り込み許可フリップフロップ）

| 名称 | 役割 |
|---|---|
| `IFF1` | 通常のマスク可能割り込み（INT）許可状態 |
| `IFF2` | `IFF1` のバックアップ。NMI 前後の復帰制御で使われる |

- `DI`: `IFF1=0`, `IFF2=0`
- `EI`: 次命令実行後に `IFF1=1`, `IFF2=1`
- `RETN`: `IFF2` の値を `IFF1` へ復帰
- `LD A,I` / `LD A,R`: `P/V` に `IFF2` が反映される

### 0.5 タイミング記法補足

- 条件付き命令の `M/T` は「成立/不成立」で分かれる
- ブロック命令（`LDIR`, `CPIR`, `INIR` など）は「継続時/終了時」で分かれる

---

## 1. メモリ転送（LD, EX, EXX）

### `LD`

`LD` はデータ転送命令です。算術は行わず、基本的にフラグは変化しません。

#### `r` と `r'` の意味

- `LD r,r'` の `r` は転送先、`r'` は転送元の 8bit レジスタコードです。
- 例: `LD D,E` は `r=D`, `r'=E`。

#### 主要形式（基本）

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `LD r,r'` | `01dddsss`（`0x40..0x7F`, `0x76`除く） | 1 | 4 | `-` |
| `LD r,n` | `00ddd110 imm8`（`06/0E/16/1E/26/2E/3E`） | 2 | 7 | `-` |
| `LD r,(HL)` | `01ddd110`（`46/4E/56/5E/66/6E/7E`） | 2 | 7 | `-` |
| `LD (HL),r` | `01110sss`（`70/71/72/73/74/75/77`） | 2 | 7 | `-` |
| `LD (HL),n` | `36 imm8` | 3 | 10 | `-` |

#### IX/IY 間接形式（`DD`/`FD` を明示展開）

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `LD r,(IX+d)` | `DD 01ddd110 disp8` | 5 | 19 | `-` |
| `LD r,(IY+d)` | `FD 01ddd110 disp8` | 5 | 19 | `-` |
| `LD (IX+d),r` | `DD 01110sss disp8` | 5 | 19 | `-` |
| `LD (IY+d),r` | `FD 01110sss disp8` | 5 | 19 | `-` |
| `LD (IX+d),n` | `DD 36 disp8 imm8` | 5 | 19 | `-` |
| `LD (IY+d),n` | `FD 36 disp8 imm8` | 5 | 19 | `-` |

#### A と BC/DE/nn の間接転送

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `LD A,(BC)` | `0A` | 2 | 7 | `-` |
| `LD A,(DE)` | `1A` | 2 | 7 | `-` |
| `LD (BC),A` | `02` | 2 | 7 | `-` |
| `LD (DE),A` | `12` | 2 | 7 | `-` |
| `LD A,(nn)` | `3A i16L i16H` | 4 | 13 | `-` |
| `LD (nn),A` | `32 i16L i16H` | 4 | 13 | `-` |

#### 16bit ロード（`rr/dd` 展開表を明示）

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `LD BC,nn` | `01 i16L i16H` | 3 | 10 | `-` |
| `LD DE,nn` | `11 i16L i16H` | 3 | 10 | `-` |
| `LD HL,nn` | `21 i16L i16H` | 3 | 10 | `-` |
| `LD SP,nn` | `31 i16L i16H` | 3 | 10 | `-` |
| `LD IX,nn` | `DD 21 i16L i16H` | 4 | 14 | `-` |
| `LD IY,nn` | `FD 21 i16L i16H` | 4 | 14 | `-` |
| `LD HL,(nn)` | `2A i16L i16H` | 5 | 16 | `-` |
| `LD (nn),HL` | `22 i16L i16H` | 5 | 16 | `-` |
| `LD IX,(nn)` | `DD 2A i16L i16H` | 6 | 20 | `-` |
| `LD IY,(nn)` | `FD 2A i16L i16H` | 6 | 20 | `-` |
| `LD (nn),IX` | `DD 22 i16L i16H` | 6 | 20 | `-` |
| `LD (nn),IY` | `FD 22 i16L i16H` | 6 | 20 | `-` |

`LD dd,(nn)` / `LD (nn),dd` は以下のように展開されます。

| 命令 | バイトコード | M | T |
|---|---|---:|---:|
| `LD BC,(nn)` | `ED 4B i16L i16H` | 6 | 20 |
| `LD DE,(nn)` | `ED 5B i16L i16H` | 6 | 20 |
| `LD HL,(nn)` | `ED 6B i16L i16H` | 6 | 20 |
| `LD SP,(nn)` | `ED 7B i16L i16H` | 6 | 20 |
| `LD (nn),BC` | `ED 43 i16L i16H` | 6 | 20 |
| `LD (nn),DE` | `ED 53 i16L i16H` | 6 | 20 |
| `LD (nn),HL` | `ED 63 i16L i16H` | 6 | 20 |
| `LD (nn),SP` | `ED 73 i16L i16H` | 6 | 20 |

#### 特殊ロード

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `LD SP,HL` | `F9` | 2 | 6 | `-` |
| `LD SP,IX` | `DD F9` | 2 | 10 | `-` |
| `LD SP,IY` | `FD F9` | 2 | 10 | `-` |
| `LD I,A` | `ED 47` | 2 | 9 | `-` |
| `LD R,A` | `ED 4F` | 2 | 9 | `-` |
| `LD A,I` | `ED 57` | 2 | 9 | `S* Z* Y* H=0 X* P/V=IFF2 N=0 C=-` |
| `LD A,R` | `ED 5F` | 2 | 9 | `S* Z* Y* H=0 X* P/V=IFF2 N=0 C=-` |

#### IXH/IXL/IYH/IYL（本実装対応）

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `LD IXH,n` | `DD 26 imm8` | 2 | 8 | `-` |
| `LD IXL,n` | `DD 2E imm8` | 2 | 8 | `-` |
| `LD IYH,n` | `FD 26 imm8` | 2 | 8 | `-` |
| `LD IYL,n` | `FD 2E imm8` | 2 | 8 | `-` |

`LD` でフラグ更新する例外は **`LD A,I` と `LD A,R` だけ**です。

### `EX`

値を交換する命令です。退避領域を使わずにレジスタ内容を入れ替えられます。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `EX DE,HL` | `EB` | 1 | 4 | `-` |
| `EX AF,AF'` | `08` | 1 | 4 | `-` |
| `EX (SP),HL` | `E3` | 6 | 19 | `-` |
| `EX (SP),IX` | `DD E3` | 6 | 23 | `-` |
| `EX (SP),IY` | `FD E3` | 6 | 23 | `-` |
| `EX DE,IX`（実装互換） | `DD EB` | 2 | 8 | `-` |
| `EX DE,IY`（実装互換） | `FD EB` | 2 | 8 | `-` |

### `EXX`

`BC/DE/HL` とシャドウ `BC'/DE'/HL'` を同時交換します。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `EXX` | `D9` | 1 | 4 | `-` |

---

## 2. スタック操作

### `PUSH`

16bit 値をスタックに積みます。`SP` は 2 減少。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `PUSH BC` | `C5` | 3 | 11 | `-` |
| `PUSH DE` | `D5` | 3 | 11 | `-` |
| `PUSH HL` | `E5` | 3 | 11 | `-` |
| `PUSH AF` | `F5` | 3 | 11 | `-` |
| `PUSH IX` | `DD E5` | 4 | 15 | `-` |
| `PUSH IY` | `FD E5` | 4 | 15 | `-` |

### `POP`

スタックから 16bit 値を取り出します。`SP` は 2 増加。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `POP BC` | `C1` | 3 | 10 | `-` |
| `POP DE` | `D1` | 3 | 10 | `-` |
| `POP HL` | `E1` | 3 | 10 | `-` |
| `POP AF` | `F1` | 3 | 10 | `F` が復元される |
| `POP IX` | `DD E1` | 4 | 14 | `-` |
| `POP IY` | `FD E1` | 4 | 14 | `-` |

---

## 3. 算術

### `ADD`

#### 動作

- `ADD A,x`: `A_new' = A + x`
- `ADD HL,rr`: `HL_new' = HL + rr`
- `ADD IX,pp` / `ADD IY,pp`: `IX/IY` へ 16bit 加算

#### 形式とバイトコード

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `ADD A,r` | `80 + r`（`80..87`） | 1 | 4 |
| `ADD A,n` | `C6 imm8` | 2 | 7 |
| `ADD A,(HL)` | `86` | 2 | 7 |
| `ADD A,(IX+d)` | `DD 86 disp8` | 5 | 19 |
| `ADD A,(IY+d)` | `FD 86 disp8` | 5 | 19 |
| `ADD HL,BC` | `09` | 3 | 11 |
| `ADD HL,DE` | `19` | 3 | 11 |
| `ADD HL,HL` | `29` | 3 | 11 |
| `ADD HL,SP` | `39` | 3 | 11 |
| `ADD IX,BC` | `DD 09` | 4 | 15 |
| `ADD IX,DE` | `DD 19` | 4 | 15 |
| `ADD IX,IX` | `DD 29` | 4 | 15 |
| `ADD IX,SP` | `DD 39` | 4 | 15 |
| `ADD IY,BC` | `FD 09` | 4 | 15 |
| `ADD IY,DE` | `FD 19` | 4 | 15 |
| `ADD IY,IY` | `FD 29` | 4 | 15 |
| `ADD IY,SP` | `FD 39` | 4 | 15 |

#### フラグ

- `ADD A,*`: `S* Z* Y* H* X* P/V* N=0 C*`
- `ADD HL,*` / `ADD IX/IY,*`: `H* N=0 C*`、`S/Z/PV` は保持

`C*` は「計算結果が 8bit（または16bit）に収まらないとき 1」です。

### `ADC`

#### 動作（キャリー入力）

- `ADC A,x`: `A_new' = A + x + C`
- `ADC HL,rr`: `HL_new' = HL + rr + C`

`ADC` は多バイト加算で上位桁を処理するための命令です。

#### 形式とバイトコード

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `ADC A,r` | `88 + r`（`88..8F`） | 1 | 4 |
| `ADC A,n` | `CE imm8` | 2 | 7 |
| `ADC A,(HL)` | `8E` | 2 | 7 |
| `ADC A,(IX+d)` | `DD 8E disp8` | 5 | 19 |
| `ADC A,(IY+d)` | `FD 8E disp8` | 5 | 19 |
| `ADC HL,BC` | `ED 4A` | 4 | 15 |
| `ADC HL,DE` | `ED 5A` | 4 | 15 |
| `ADC HL,HL` | `ED 6A` | 4 | 15 |
| `ADC HL,SP` | `ED 7A` | 4 | 15 |

#### フラグ

- `ADC A,*`: `ADD A,*` と同じ（carry 入力あり）
- `ADC HL,*`: `S* Z* H* P/V* N=0 C*`

### `SUB`

#### 動作

- `SUB x`: `A_new' = A - x`

#### 形式とバイトコード

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `SUB r` | `90 + r`（`90..97`） | 1 | 4 |
| `SUB n` | `D6 imm8` | 2 | 7 |
| `SUB (HL)` | `96` | 2 | 7 |
| `SUB (IX+d)` | `DD 96 disp8` | 5 | 19 |
| `SUB (IY+d)` | `FD 96 disp8` | 5 | 19 |

#### フラグ

`S* Z* Y* H* X* P/V* N=1 C*`

### `SBC`

#### 動作（キャリー入力）

- `SBC A,x`: `A_new' = A - x - C`
- `SBC HL,rr`: `HL_new' = HL - rr - C`

`SBC` は多バイト減算で上位桁を処理するための命令です。

#### 形式とバイトコード

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `SBC A,r` | `98 + r`（`98..9F`） | 1 | 4 |
| `SBC A,n` | `DE imm8` | 2 | 7 |
| `SBC A,(HL)` | `9E` | 2 | 7 |
| `SBC A,(IX+d)` | `DD 9E disp8` | 5 | 19 |
| `SBC A,(IY+d)` | `FD 9E disp8` | 5 | 19 |
| `SBC HL,BC` | `ED 42` | 4 | 15 |
| `SBC HL,DE` | `ED 52` | 4 | 15 |
| `SBC HL,HL` | `ED 62` | 4 | 15 |
| `SBC HL,SP` | `ED 72` | 4 | 15 |

#### フラグ

- `SBC A,*`: `SUB` と同じ（carry 入力あり）
- `SBC HL,*`: `S* Z* H* P/V* N=1 C*`

### `INC`

#### 動作

- 8bit: `x' = x + 1`
- 16bit: `xx' = xx + 1`

#### 形式とバイトコード

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `INC B` | `04` | 1 | 4 |
| `INC C` | `0C` | 1 | 4 |
| `INC D` | `14` | 1 | 4 |
| `INC E` | `1C` | 1 | 4 |
| `INC H` | `24` | 1 | 4 |
| `INC L` | `2C` | 1 | 4 |
| `INC A` | `3C` | 1 | 4 |
| `INC (HL)` | `34` | 3 | 11 |
| `INC (IX+d)` | `DD 34 disp8` | 6 | 23 |
| `INC (IY+d)` | `FD 34 disp8` | 6 | 23 |
| `INC BC` | `03` | 1 | 6 |
| `INC DE` | `13` | 1 | 6 |
| `INC HL` | `23` | 1 | 6 |
| `INC SP` | `33` | 1 | 6 |
| `INC IX` | `DD 23` | 2 | 10 |
| `INC IY` | `FD 23` | 2 | 10 |

#### フラグ（8bit 形式のみ）

`S* Z* Y* H* X* P/V* N=0 C=-`

- `C=-` なので、`INC A` でオーバーフローしても `C` は変化しません。
- `H*` は下位ニブルが `0xF -> 0x0` になったとき 1。
- `P/V*` は `0x7F -> 0x80` のとき 1。

### `DEC`

#### 動作

- 8bit: `x' = x - 1`
- 16bit: `xx' = xx - 1`

#### 形式とバイトコード

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `DEC B` | `05` | 1 | 4 |
| `DEC C` | `0D` | 1 | 4 |
| `DEC D` | `15` | 1 | 4 |
| `DEC E` | `1D` | 1 | 4 |
| `DEC H` | `25` | 1 | 4 |
| `DEC L` | `2D` | 1 | 4 |
| `DEC A` | `3D` | 1 | 4 |
| `DEC (HL)` | `35` | 3 | 11 |
| `DEC (IX+d)` | `DD 35 disp8` | 6 | 23 |
| `DEC (IY+d)` | `FD 35 disp8` | 6 | 23 |
| `DEC BC` | `0B` | 1 | 6 |
| `DEC DE` | `1B` | 1 | 6 |
| `DEC HL` | `2B` | 1 | 6 |
| `DEC SP` | `3B` | 1 | 6 |
| `DEC IX` | `DD 2B` | 2 | 10 |
| `DEC IY` | `FD 2B` | 2 | 10 |

#### フラグ（8bit 形式のみ）

`S* Z* Y* H* X* P/V* N=1 C=-`

- `H*` は「必ず 1」ではありません。
- `H=1` になるのは下位ニブルで借りが発生するとき（例: `0x10 -> 0x0F`）。
- `P/V=1` は `0x80 -> 0x7F` のとき。

### `NEG`

#### 動作

`A_new' = 0 - A`（2の補数化）

- 正数を負数へ、負数を正数へ符号反転したいときに使う。
- `CPL` + `INC A` と等価の結果になるが、`NEG` は1命令でフラグも正しく更新される。

#### 形式とバイトコード

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `NEG` | `ED 44` | 2 | 8 |

#### フラグ

`S* Z* Y* H* X* P/V* N=1 C*`

- `C=1`: `A != 00H`
- `C=0`: `A == 00H`
- `P/V=1`: `A == 80H`（-128 の符号反転は表現不能）
- `H=1`: 下位ニブル借りが発生した場合（概ね `A` の下位ニブルが 0 でないとき）

---

## 4. 論理ビット演算

### `AND`

`A_new' = A AND x`

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `AND r` | `A0 + r`（`A0..A7`） | 1 | 4 | `S* Z* Y* H=1 X* P/V*(parity) N=0 C=0` |
| `AND n` | `E6 imm8` | 2 | 7 | 同上 |
| `AND (HL)` | `A6` | 2 | 7 | 同上 |
| `AND (IX+d)` | `DD A6 disp8` | 5 | 19 | 同上 |
| `AND (IY+d)` | `FD A6 disp8` | 5 | 19 | 同上 |

### `OR`

`A_new' = A OR x`

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `OR r` | `B0 + r`（`B0..B7`） | 1 | 4 | `S* Z* Y* H=0 X* P/V*(parity) N=0 C=0` |
| `OR n` | `F6 imm8` | 2 | 7 | 同上 |
| `OR (HL)` | `B6` | 2 | 7 | 同上 |
| `OR (IX+d)` | `DD B6 disp8` | 5 | 19 | 同上 |
| `OR (IY+d)` | `FD B6 disp8` | 5 | 19 | 同上 |

### `XOR`

`A_new' = A XOR x`

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `XOR r` | `A8 + r`（`A8..AF`） | 1 | 4 | `OR` と同じ |
| `XOR n` | `EE imm8` | 2 | 7 | 同上 |
| `XOR (HL)` | `AE` | 2 | 7 | 同上 |
| `XOR (IX+d)` | `DD AE disp8` | 5 | 19 | 同上 |
| `XOR (IY+d)` | `FD AE disp8` | 5 | 19 | 同上 |

### `BIT`

指定ビットを調べてフラグへ反映する（オペランドは不変）。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `BIT b,r` | `CB (40 + 8*b + r)` | 2 | 8 |
| `BIT b,(HL)` | `CB (46 + 8*b)` | 3 | 12 |
| `BIT b,(IX+d)` | `DD CB disp8 (46 + 8*b)` | 5 | 20 |
| `BIT b,(IY+d)` | `FD CB disp8 (46 + 8*b)` | 5 | 20 |

フラグ: `Z* H=1 N=0 C=-`、`S*` は `b=7` のときのみ意味を持つ。

### `RES`

指定ビットを 0 にクリア。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `RES b,r` | `CB (80 + 8*b + r)` | 2 | 8 | `-` |
| `RES b,(HL)` | `CB (86 + 8*b)` | 4 | 15 | `-` |
| `RES b,(IX+d)` | `DD CB disp8 (86 + 8*b)` | 6 | 23 | `-` |
| `RES b,(IY+d)` | `FD CB disp8 (86 + 8*b)` | 6 | 23 | `-` |

### `SET`

指定ビットを 1 にセット。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `SET b,r` | `CB (C0 + 8*b + r)` | 2 | 8 | `-` |
| `SET b,(HL)` | `CB (C6 + 8*b)` | 4 | 15 | `-` |
| `SET b,(IX+d)` | `DD CB disp8 (C6 + 8*b)` | 6 | 23 | `-` |
| `SET b,(IY+d)` | `FD CB disp8 (C6 + 8*b)` | 6 | 23 | `-` |

---

## 5. 比較（CP）

### `CP`

`CP x` は **`A - x` を内部で計算し、結果は捨ててフラグだけ更新**します。
`A` は書き換わりません。

#### 形式とバイトコード

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `CP r` | `B8 + r`（`B8..BF`） | 1 | 4 |
| `CP n` | `FE imm8` | 2 | 7 |
| `CP (HL)` | `BE` | 2 | 7 |
| `CP (IX+d)` | `DD BE disp8` | 5 | 19 |
| `CP (IY+d)` | `FD BE disp8` | 5 | 19 |

#### フラグの意味（`tmp = A_ - x`）

- `S = bit7(tmp)`
- `Z = (tmp == 0)`
- `H = 下位ニブルで借りが発生したら 1`
- `P/V = 符号付きオーバーフローなら 1`
- `N = 1`
- `C = 借りが発生したら 1`（unsigned で `A < x`）
- `Y/X = tmp の bit5/bit3`

`SUB` と同じと言うのは「**演算規則が同じ**」という意味で、`CP` は `A` を書き換えない点だけが違います。

---

## 6. 分岐（JP/CALL/RET/RST）

### 条件コード対応表（`cond`）

| 条件 | 意味 | `JP cond,nn` | `CALL cond,nn` | `RET cond` |
|---|---|---|---|---|
| `NZ` | `Z=0` | `C2` | `C4` | `C0` |
| `Z`  | `Z=1` | `CA` | `CC` | `C8` |
| `NC` | `C=0` | `D2` | `D4` | `D0` |
| `C`  | `C=1` | `DA` | `DC` | `D8` |
| `PO` | `P/V=0` | `E2` | `E4` | `E0` |
| `PE` | `P/V=1` | `EA` | `EC` | `E8` |
| `P`  | `S=0` | `F2` | `F4` | `F0` |
| `M`  | `S=1` | `FA` | `FC` | `F8` |

### 条件成立/不成立で M/T が変わる理由（読み方）

条件付き命令では、条件不成立のときに「実行しない処理」があるため M/T が短くなる命令があります。

| 命令 | 成立時 | 不成立時 | 差分理由 |
|---|---:|---:|---|
| `JR cond,e` | `3M / 12T` | `2M / 7T` | 成立時のみ `PC` 更新の追加サイクルが必要 |
| `DJNZ e` | `3M / 13T` | `2M / 8T` | 成立時のみ相対分岐処理を実行 |
| `CALL cond,nn` | `5M / 17T` | `3M / 10T` | 成立時のみ戻り先 push（メモリ書き込み2回） |
| `RET cond` | `3M / 11T` | `1M / 5T` | 成立時のみスタック pop（メモリ読み出し2回） |

補足:

- `JP cond,nn` は成立/不成立で `3M / 10T` が同じです。`nn` 読み込みコストは常に発生するためです。

### `JP`

絶対ジャンプ。`JP (HL)`/`JP (IX)`/`JP (IY)` はレジスタ間接ジャンプ。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `JP nn` | `C3 i16L i16H` | 3 | 10 | `-` |
| `JP cond,nn` | `cond` 表の opcode + `i16L i16H` | 3 | 10 | `-` |
| `JP (HL)` | `E9` | 1 | 4 | `-` |
| `JP (IX)` | `DD E9` | 2 | 8 | `-` |
| `JP (IY)` | `FD E9` | 2 | 8 | `-` |

### `JR`

相対ジャンプ。`PC_new' = PC + 2 + sign_extend(e)`。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `JR e` | `18 rel8` | 3 | 12 | `-` |
| `JR NZ,e` | `20 rel8` | 3/2 | 12/7 | `-` |
| `JR Z,e` | `28 rel8` | 3/2 | 12/7 | `-` |
| `JR NC,e` | `30 rel8` | 3/2 | 12/7 | `-` |
| `JR C,e` | `38 rel8` | 3/2 | 12/7 | `-` |

### `DJNZ`

`B_new' = B - 1`。`B' != 0` なら `JR` 相対分岐。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `DJNZ e` | `10 rel8` | 3/2 | 13/8 | `-` |

### `CALL`

サブルーチン呼び出し。

- 戻り先アドレス: `ret = PC + 3`
- `SP_new' = SP - 2`
- スタック内容: `(SP') = retL`, `(SP'+1) = retH`
- `PC' = nn`

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `CALL nn` | `CD i16L i16H` | 5 | 17 | `-` |
| `CALL cond,nn` | `cond` 表の opcode + `i16L i16H` | 5/3 | 17/10 | `-` |

### `RET`

サブルーチン復帰。

- `PC' = (SP)` と `(SP+1)` から復元
- `SP_new' = SP_ + 2`

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `RET` | `C9` | 3 | 10 | `-` |
| `RET cond` | `cond` 表の opcode | 3/1 | 11/5 | `-` |

### `RETI`

割り込みハンドラから復帰するための命令。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `RETI` | `ED 4D` | 4 | 14 | `-` |

### `RETN`

NMI ハンドラ復帰向け。`IFF1 <- IFF2` の復帰動作を伴う。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `RETN` | `ED 45` | 4 | 14 | `-` |

### `RST`

固定ベクタへの短縮 `CALL`。1byte で呼び出せるため、割り込みベクタや小さな共通ルーチン呼び出しに使います。

動作:

- 戻り先アドレス: `ret = PC + 1`
- `SP_new' = SP - 2`
- `(SP') = retL`, `(SP'+1) = retH`
- `PC' = vector`（`00H/08H/10H/18H/20H/28H/30H/38H` のいずれか）

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `RST 00H` | `C7` | 3 | 11 | `-` |
| `RST 08H` | `CF` | 3 | 11 | `-` |
| `RST 10H` | `D7` | 3 | 11 | `-` |
| `RST 18H` | `DF` | 3 | 11 | `-` |
| `RST 20H` | `E7` | 3 | 11 | `-` |
| `RST 28H` | `EF` | 3 | 11 | `-` |
| `RST 30H` | `F7` | 3 | 11 | `-` |
| `RST 38H` | `FF` | 3 | 11 | `-` |

---

## 7. ブロック処理とサーチ（CPI 系）

### `CPI`

`A` と `(HL)` を比較しつつ、`HL++`, `BC--`。
メモリを前方向に 1byte ずつ走査し、`A` と一致する値を探す用途に使います。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `CPI` | `ED A1` | 5 | 16 |

フラグ:

- 比較部は `CP (HL)` と同様
- `P/V = 1` if `BC` が実行後に 0 でない
- `P/V = 0` if `BC` が実行後に 0
- `C` は保持

### `CPD`

`CPI` の後退版（`HL--`, `BC--`）。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `CPD` | `ED A9` | 5 | 16 |

フラグ: `CPI` と同じ

### `CPIR`

`CPI` を自動反復。

- 継続条件: `BC != 0` かつ `Z == 0`
- 終了条件: `BC == 0` または `Z == 1`

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `CPIR`（継続） | `ED B1` | 6 | 21 |
| `CPIR`（終了） | `ED B1` | 5 | 16 |

フラグ: `CPI` と同じ

### `CPDR`

`CPD` の自動反復版。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `CPDR`（継続） | `ED B9` | 6 | 21 |
| `CPDR`（終了） | `ED B9` | 5 | 16 |

フラグ: `CPD` と同じ

---

## 8. ブロック転送（LDI 系）

### `LDI`

`(DE) <- (HL)`、`HL++`, `DE++`, `BC--`。
前方向への 1byte コピー命令で、`memcpy` 的な処理の最小単位です。

実行順序（概念）:

1. `mem[DE] = mem[HL]`
2. `HL_new = HL + 1`
3. `DE_new = DE + 1`
4. `BC_new = BC - 1`

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `LDI` | `ED A0` | 5 | 16 | `H=0 N=0 P/V* C=-` |

フラグ補足:

- `P/V=1`: 実行後 `BC != 0`（まだコピー残量あり）
- `P/V=0`: 実行後 `BC == 0`（コピー完了）
- `S/Z` は保持、`C` も保持

### `LDD`

`LDI` の後退版（`HL--`, `DE--`, `BC--`）。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `LDD` | `ED A8` | 5 | 16 | `LDI` と同じ |

### `LDIR`

`LDI` を `BC==0` まで反復。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `LDIR`（継続） | `ED B0` | 6 | 21 | `LDI` と同じ |
| `LDIR`（終了） | `ED B0` | 5 | 16 | `LDI` と同じ |

### `LDDR`

`LDD` を `BC==0` まで反復。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `LDDR`（継続） | `ED B8` | 6 | 21 | `LDD` と同じ |
| `LDDR`（終了） | `ED B8` | 5 | 16 | `LDD` と同じ |

---

## 9. ローテート/シフト（RL*, RR*, SLA/SRA）

### `R*` と `S*` の違い（先に読むと分かりやすい）

- `R*`（Rotate）は**回転**:
  - 端から出たビットを反対側またはキャリーへ回す。
  - 元の情報を循環させる操作で、純粋な乗算/除算にはならない。
- `S*`（Shift）は**シフト**:
  - 端から出たビットは捨て、空いた側へ `0/1/符号bit` を入れる。
  - 数値演算として意味づけしやすい。

代表例:

- `SLA`: 左シフト（概ね 2 倍、ただしあふれで上位ビット喪失）
- `SRA`: 算術右シフト（符号bit保持。符号付き値の右シフト向け）
- `SRL`: 論理右シフト（bit7 に 0 を入れる。符号なし値向け）
- `RL` / `RR`: キャリーを通る回転で、多バイトシフト連結に使える

### `RLCA`

`A` を 1bit 左ローテート。

- `実行前の bit7 -> C`
- `実行前の bit7 -> 結果 bit0`

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `RLCA` | `07` | 1 | 4 | `C=実行前bit7 H=0 N=0`（`S/Z/PV`保持） |

### `RRCA`

`A` を 1bit 右ローテート。

- `実行前の bit0 -> C`
- `実行前の bit0 -> 結果 bit7`

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `RRCA` | `0F` | 1 | 4 | `C=実行前bit0 H=0 N=0`（`S/Z/PV`保持） |

### `RLA`

キャリー経由左ローテート。

- `実行前の bit7 -> C`
- `実行前の C -> 結果 bit0`

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `RLA` | `17` | 1 | 4 | `C=実行前bit7 H=0 N=0`（`S/Z/PV`保持） |

### `RRA`

キャリー経由右ローテート。

- `実行前の bit0 -> C`
- `実行前の C -> 結果 bit7`

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `RRA` | `1F` | 1 | 4 | `C=実行前bit0 H=0 N=0`（`S/Z/PV`保持） |

### `RLC`

対象を左ローテート（`実行前bit7` を `C` と bit0 に入れる）。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `RLC r` | `CB (00 + r)` | 2 | 8 |
| `RLC (HL)` | `CB 06` | 4 | 15 |
| `RLC (IX+d)` | `DD CB disp8 06` | 6 | 23 |
| `RLC (IY+d)` | `FD CB disp8 06` | 6 | 23 |

フラグ: `S* Z* Y* H=0 X* P/V* N=0 C=実行前bit7`

### `RL`

キャリー経由左ローテート。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `RL r` | `CB (10 + r)` | 2 | 8 |
| `RL (HL)` | `CB 16` | 4 | 15 |
| `RL (IX+d)` | `DD CB disp8 16` | 6 | 23 |
| `RL (IY+d)` | `FD CB disp8 16` | 6 | 23 |

フラグ: `RLC` と同じ規則（`C=実行前bit7`）

### `RRC`

対象を右ローテート（`実行前bit0` を `C` と bit7 に入れる）。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `RRC r` | `CB (08 + r)` | 2 | 8 |
| `RRC (HL)` | `CB 0E` | 4 | 15 |
| `RRC (IX+d)` | `DD CB disp8 0E` | 6 | 23 |
| `RRC (IY+d)` | `FD CB disp8 0E` | 6 | 23 |

フラグ: `RLC` と同じ規則（`C=実行前bit0`）

### `RR`

キャリー経由右ローテート。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `RR r` | `CB (18 + r)` | 2 | 8 |
| `RR (HL)` | `CB 1E` | 4 | 15 |
| `RR (IX+d)` | `DD CB disp8 1E` | 6 | 23 |
| `RR (IY+d)` | `FD CB disp8 1E` | 6 | 23 |

フラグ: `RLC` と同じ規則（`C=実行前bit0`）

### `SLA`

算術左シフト。`実行前bit7 -> C`、bit0 には 0 が入る。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `SLA r` | `CB (20 + r)` | 2 | 8 |
| `SLA (HL)` | `CB 26` | 4 | 15 |
| `SLA (IX+d)` | `DD CB disp8 26` | 6 | 23 |
| `SLA (IY+d)` | `FD CB disp8 26` | 6 | 23 |

フラグ: `RLC` と同じ規則（`C=実行前bit7`）

### `SRA`

算術右シフト。`実行前bit7`（符号）を保持し、`実行前bit0 -> C`。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `SRA r` | `CB (28 + r)` | 2 | 8 |
| `SRA (HL)` | `CB 2E` | 4 | 15 |
| `SRA (IX+d)` | `DD CB disp8 2E` | 6 | 23 |
| `SRA (IY+d)` | `FD CB disp8 2E` | 6 | 23 |

フラグ: `RLC` と同じ規則（`C=実行前bit0`）

### `SLL`

左シフト。bit0 に常に 1 を入れる（undocumented だが本実装で対応）。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `SLL r` | `CB (30 + r)` | 2 | 8 |
| `SLL (HL)` | `CB 36` | 4 | 15 |
| `SLL (IX+d)` | `DD CB disp8 36` | 6 | 23 |
| `SLL (IY+d)` | `FD CB disp8 36` | 6 | 23 |

フラグ: `RLC` と同じ規則（`C=実行前bit7`）

### `SRL`

論理右シフト。bit7 に 0 を入れ、`実行前bit0 -> C`。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `SRL r` | `CB (38 + r)` | 2 | 8 |
| `SRL (HL)` | `CB 3E` | 4 | 15 |
| `SRL (IX+d)` | `DD CB disp8 3E` | 6 | 23 |
| `SRL (IY+d)` | `FD CB disp8 3E` | 6 | 23 |

フラグ: `RLC` と同じ規則（`C=実行前bit0`）

---

## 10. CPU 制御

### `NOP`

何もしない。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `NOP` | `00` | 1 | 4 | `-` |

### `HALT`

CPU を停止状態へ。割り込みで復帰。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `HALT` | `76` | 1 | 4（停止中は4T反復） | `-` |

実装上の備考（エミュレータ）:

- 命令仕様上は HALT 中に 4T 単位で待機が続きます。
- ただしホスト側実装で毎回「1ステップ=4T」を高頻度ループすると、イベント待ちがない構成ではCPU負荷が上がりやすいです。
- 実装では次のようにするのが実用的です。
  - `halted` 状態を保持し、割り込み/外部イベント発生まで実行本体をスキップ
  - その間の仮想時間はまとめて進める（バッチ加算）
  - サイクル精度が必要なモードのみ細粒度ステップへ切替

### `DI`

マスク可能割り込みを禁止。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `DI` | `F3` | 1 | 4 | `-` |

### `EI`

マスク可能割り込みを許可（有効化は次命令の後）。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `EI` | `FB` | 1 | 4 | `-` |

### `IM`

割り込みモード設定。

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `IM 0` | `ED 46` | 2 | 8 | `-` |
| `IM 1` | `ED 56` | 2 | 8 | `-` |
| `IM 2` | `ED 5E` | 2 | 8 | `-` |

### `CCF`

キャリーを反転。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `CCF` | `3F` | 1 | 4 |

フラグ: `C_new=!C`, `H=C`, `N=0`, `S/Z/PV` 保持

### `SCF`

キャリーを 1 にする。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `SCF` | `37` | 1 | 4 |

フラグ: `C=1`, `H=0`, `N=0`, `S/Z/PV` 保持

### `CPL`

`A` の全ビット反転。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `CPL` | `2F` | 1 | 4 |

フラグ: `H=1`, `N=1`、他保持

---

## 11. 入力

### `IN`

`IN` には 2 系統あります。

- `IN A,(n)`: **固定ポート番号**（即値）から読み込む
- `IN r,(C)`: **実行時に `C` で指定したポート番号**から読み込む

用途の違い:

- `IN A,(n)` は「このデバイスは常にポート `40H`」のような固定 I/O に向く
- `IN r,(C)` はループ処理やデバイス切替など動的 I/O に向く

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `IN A,(n)` | `DB imm8` | 3 | 11 | `-` |
| `IN B,(C)` | `ED 40` | 4 | 12 | `S* Z* P/V* H=0 N=0 C=-` |
| `IN C,(C)` | `ED 48` | 4 | 12 | 同上 |
| `IN D,(C)` | `ED 50` | 4 | 12 | 同上 |
| `IN E,(C)` | `ED 58` | 4 | 12 | 同上 |
| `IN H,(C)` | `ED 60` | 4 | 12 | 同上 |
| `IN L,(C)` | `ED 68` | 4 | 12 | 同上 |
| `IN A,(C)` | `ED 78` | 4 | 12 | 同上 |

### `INI`

`(C)` から読み込んだ 1byte を `(HL)` へ保存し、`HL++`, `B--`。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `INI` | `ED A2` | 5 | 16 |

フラグ: ブロック I/O 規則

### `IND`

`INI` の後退版（`HL--`, `B--`）。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `IND` | `ED AA` | 5 | 16 |

フラグ: `INI` と同系

### `INIR`

`INI` を `B==0` まで反復。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `INIR`（継続） | `ED B2` | 6 | 21 |
| `INIR`（終了） | `ED B2` | 5 | 16 |

フラグ: `INI` と同系

### `INDR`

`IND` を `B==0` まで反復。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `INDR`（継続） | `ED BA` | 6 | 21 |
| `INDR`（終了） | `ED BA` | 5 | 16 |

フラグ: `IND` と同系

---

## 12. 出力

### `OUT`

| 形式 | バイトコード | M | T | フラグ |
|---|---|---:|---:|---|
| `OUT (n),A` | `D3 imm8` | 3 | 11 | `-` |
| `OUT (C),B` | `ED 41` | 4 | 12 | `-` |
| `OUT (C),C` | `ED 49` | 4 | 12 | `-` |
| `OUT (C),D` | `ED 51` | 4 | 12 | `-` |
| `OUT (C),E` | `ED 59` | 4 | 12 | `-` |
| `OUT (C),H` | `ED 61` | 4 | 12 | `-` |
| `OUT (C),L` | `ED 69` | 4 | 12 | `-` |
| `OUT (C),A` | `ED 79` | 4 | 12 | `-` |

### `OUTI`

`(HL)` を `(C)` へ出力し、`HL++`, `B--`。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `OUTI` | `ED A3` | 5 | 16 |

フラグ: ブロック I/O 規則

### `OUTD`

`OUTI` の後退版（`HL--`, `B--`）。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `OUTD` | `ED AB` | 5 | 16 |

フラグ: `OUTI` と同系

### `OTIR`

`OUTI` を `B==0` まで反復。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `OTIR`（継続） | `ED B3` | 6 | 21 |
| `OTIR`（終了） | `ED B3` | 5 | 16 |

フラグ: `OUTI` と同系

### `OTDR`

`OUTD` を `B==0` まで反復。

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `OTDR`（継続） | `ED BB` | 6 | 21 |
| `OTDR`（終了） | `ED BB` | 5 | 16 |

フラグ: `OUTD` と同系

---

## 13. BCD 命令

### `DAA`

`DAA` は、直前の `ADD/ADC/SUB/SBC` 結果を packed BCD として補正する命令です。

#### 使い方の基本

1. まず 2桁 BCD 同士を通常の `ADD`/`SUB` で計算する
2. 直後に `DAA` を実行して BCD へ正規化する

#### 補正の考え方（概念）

- `N=0`（加算系）:
  - 下位桁が 10 以上、または `H=1` なら `+06`
  - 上位桁が 10 以上、または `C=1` なら `+60`
- `N=1`（減算系）:
  - `H=1` なら `-06`
  - `C=1` なら `-60`

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `DAA` | `27` | 1 | 4 |

フラグ:

- `S* Z* P/V*` は補正後 `A` に依存
- `H*` は補正過程に依存
- `C*` は補正時に更新
- `N` は保持

#### 例（加算）

```asm
LD A,25H
ADD A,37H   ; A=5CH (2進としての結果)
DAA         ; A=62H (BCDとして正規化)
```

### `RLD`

`A` の下位ニブルと `(HL)` の上下ニブルを左回転方向に交換する BCD 補助命令。

| 実行前 | 実行後 |
|---|---|
| `A = Ah:Al`, `(HL)=Mh:Ml` | `A = Ah:Mh`, `(HL)=Ml:Al` |

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `RLD` | `ED 6F` | 5 | 18 |

フラグ: `S* Z* P/V* H=0 N=0 C=-`

### `RRD`

`RLD` と逆方向のニブル交換。

| 実行前 | 実行後 |
|---|---|
| `A = Ah:Al`, `(HL)=Mh:Ml` | `A = Ah:Ml`, `(HL)=Al:Mh` |

| 形式 | バイトコード | M | T |
|---|---|---:|---:|
| `RRD` | `ED 67` | 5 | 18 |

フラグ: `RLD` と同じ

---

## 付録 A: バイトコード読解の実践例

### A.1 `LD r,n` を自力で展開する

- 仕様: `00ddd110 imm8`
- `ddd` を `B..A` に代入すると `06/0E/16/1E/26/2E/3E`

### A.2 `JP cond,nn` の opcode を求める

- `cond=NZ` なら `C2`
- `cond=Z` なら `CA`
- `cond=NC` なら `D2`
- `cond=C` なら `DA`
- `cond=PO/PE/P/M` なら `E2/EA/F2/FA`

### A.3 `CALL 1234H` の並び

- バイト列は `CD 34 12`（`i16L i16H`）
- 実行時に積まれる戻り先は `PC + 3`

### A.4 IX/IY + displacement

- `LD A,(IX+5)` -> `DD 7E 05`
- `LD A,(IY-3)` -> `FD 7E FD`

---

## 付録 B: 同系命令のフラグ参照関係

- `SUB` 系: `SUB`, `SBC`, `CP`, `NEG`
- `ADD` 系: `ADD`, `ADC`
- `INC/DEC` 系: 8bit 形式のみ更新、`C` 保持
- 論理系: `AND`, `OR`, `XOR`
- ビットテスト: `BIT`（`H=1`, `N=0`, `C` 保持）
- 回転/シフト（CB 系）: `RLC/RRC/RL/RR/SLA/SRA/SLL/SRL` で同型規則
- `LD` 例外: `LD A,I` / `LD A,R` のみフラグ更新
